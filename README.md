
# Tokenised Securitisation Basic Model

This set of smart contract showcases a basic functionality to securitise assets and bonds on the blockchain. It entails two different scripts with the total of 3 smart contracts to tokenize assets or bonds with the ERC721 standard, mint ERC20 tokens, and create/trade different tranches.

### Tokenize the loan
The TokenFactory smart contract serves the sole purpose of minting new tokens with their metadata and saving basic information about the loans. A struct saves basic informations about the loan, and it is mapped to a tokenId, so that each token is matched to its metadata. Counters and Events are used to keep track of unique tokenIds and minting events. The ERC721 standard is initialized upon deployment, which allows to call the function mint() with a tokenURI containing the loan metadata, the loanValue and the address of a validator (external auditor for example). The function totalSupply() allows to check the total number of the minted tokens.

### Manage securitization
The TranchePool smart contract entails simple functionalities to manage the pooling of the tokens, the creation of the tranches, the sale, and the claims over the tranches. The TrancheToken contract allows to mint ERC20 tokens that are exchanged 1:1 for stablecoins when an investor buys shares of a tranche; the payments are then deposited by the originator whenever a borrower sends the due funds, allowing the investors to call a function to claim their share of the interest or principal payments. After the ERC20 standard is initialized at deployment, basic token management functions are created: mint() and burn(). The TranchePool smart contract has an interface that allows to interact with TrancheToken. The struct Tranche is created to store tranche data, alongside various utility events, mappings and variables. The contract is then initialized through a constructor requesting the factory, an approved stablecoin, the address of the originator and a maturity timestamp. Two main functions, poolLoans() and createTranches(), allow the originator to pool its previously minted tokens and use them to create the desired tranches: by creating the tranches, new ERC20 tokens are minted 1:1 corresponding the value of the loans to the contract. Investors can now call buy() to buy the desired amount and tranche shares against stablecoins. When the borrower pays back their debt, the originator deposits interest or principal payments by calling depositInterest() or depositPrincipal(), which can later be withdrawn by invetsors with the fucntions _claimOne(), claimAll() or claim(), effectively burning the respective amount of ERC20 tokens and therefire reducing their outstanding claims.

